<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2016-03-12T00:00:00-05:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>SpartaHack 2016</title>
    <link rel="alternate" href="http://blog.url.com/2016/03/12/spartahack2016.html"/>
    <id>http://blog.url.com/2016/03/12/spartahack2016.html</id>
    <published>2016-03-12T00:00:00-05:00</published>
    <updated>2016-04-30T19:18:10-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img alt="SpartaHack 2016 logo" src="/images/spartahack-logo.png" /&gt;&lt;/p&gt;

&lt;p&gt;Starting in September, I worked alongside 19 passionate MSU students to put on Michigan State University's second annual hackathon: SpartaHack. Working as a developer and designer, I attended weekly meetings with our organizing team, where we took turns presenting updates and discussing problems to solve as a group.&lt;/p&gt;

&lt;p&gt;Although I considered myself an experienced hackathon attendee, I immediately felt lost as an organizer. Behind every hackathon, there are hard working volunteers who spends months working on an event that ends in just 36 hours. Without these volunteers, a hackathon wouldn't be the fun, safe, and educational experience every participant expects it to be. I don't think the participants realize this – but maybe that's a sign of a great hackathon.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id="my-work"&gt;My Work&lt;/h2&gt;

&lt;p&gt;When I joined the team in September, the front-facing site was already complete. &lt;a href="http://www.austintruchan.net"&gt;Austin Truchan&lt;/a&gt;, a design grad student and SpartaHack 2015 designer, had already created the logo and homepage of the SpartaHack site. The last of the work was to be done on the admin pages: specifically, pages for managing submitted applications and viewing user statistics.&lt;/p&gt;

&lt;p&gt;&lt;a href="http://www.bogdanpozderca.com"&gt;Bogdan Pozderca&lt;/a&gt; and I were the only web developers on the 2016 team. Together, we divided up the work, assigning issues on the github repo. Most of my work was on the Statistics page, where the SpartaHack organizers could view information about the applicants in a user-friendly manner.&lt;/p&gt;

&lt;p&gt;The Statistics are broken up into three different views: Application, RSVP, and Attending.&lt;/p&gt;

&lt;p&gt;The best part of the Statistics page was that it was constantly being updated through a process that closely mirrored agile development. Within two weeks, I had a working start that only showed the counts for the applications and the percentages for gender. This prototype continued to grow as new ideas were shared at each weekly meeting. Once we started accepting applicants, a new page was needed to specifically view the accepted applications. And eventually, I knew we'd need a page for the attending applicants, showing only the applicants who checked in the dat of the hackathon.&lt;/p&gt;

&lt;p&gt;Rather than create three separate pages, I decided to filter the content with radio buttons. This is nice because it decreases the number of Parse requests and allows us to compare the data back and forth quickly. The backend of the Statistics page is done in its own rails controller, which passes javascript arrays to the front end, where d3 is used to make the content pretty.&lt;/p&gt;

&lt;p&gt;Since the statistics page requires admin credentials, I’ve saved the page on my own site for anyone interested in viewing. &lt;a href="http://noahhines.com/spartahack/SpartaStats.html"&gt;http://NoahHines.com/spartahack/spartastats&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you're interested in the project, you can see the code on our public github repo here: &lt;a href="https://github.com/SpartaHack/SpartaHack2016-Website"&gt;SpartaHack2016&lt;/a&gt;&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>How Chartholdr Works</title>
    <link rel="alternate" href="http://blog.url.com/2015/07/12/chartholdr.html"/>
    <id>http://blog.url.com/2015/07/12/chartholdr.html</id>
    <published>2015-07-12T00:00:00-04:00</published>
    <updated>2016-04-30T17:09:39-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;img alt="Chartholdr pie graph" src="http://chartholdr.io/pie/200" /&gt;&lt;/p&gt;

&lt;p&gt;I remember the first time I stumbled across Placehold.it, a simple image placeholder serving plain images with text indicating the width and height. Immediately, I wondered how the site was able to deliver images with the illusion they always existed on the server.&lt;/p&gt;

&lt;p&gt;A basic image placeholder could be made by generating the images once and leaving them on the server at the appropriate URL.&lt;/p&gt;

&lt;p&gt;For instance, you could write a script that generates images between 1x1 and 1000x1000 and save them to the server's www/ folder. This would require no serverside logic, but it would be a huge waste of disk space, since there's a high chance most of the images will never be needed.&lt;/p&gt;

&lt;p&gt;I can't attest to Placehold.it's serverside logic, but I can give a technical overview of how the image placeholder I built handles dynamic image rendering and serverside caching.
&lt;/p&gt;

&lt;h2 id="routes"&gt;Routes&lt;/h2&gt;
&lt;p&gt;Taking advantage of the Ruby on Rails router, I grab the graph type, width, height (optional), and color (optional) all from one URL comprised of the following syntax.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
http://chartholdr.io/bar/1000/500/c=9d5ddd
&lt;/code&gt;
The routes.rb calls the Application Controller which initializes the generator object and sends the inline png file.&lt;/p&gt;

&lt;p&gt;The generator's constructor takes in the chart object so it knows which templates to use when rendering. If the image isn't already cached in the  public folder, the generator's get method initializes PhantomJS, renders the JS chart, saves the image to the public folder and then returns the file location.&lt;/p&gt;

&lt;p&gt;Originally, I put most of the logic in the application controller. When I realized I wanted to generate multiple chart types, however, I decided to make the process modular. As you can tell, I took advantage of abstraction whenever I could.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Router ---&amp;gt; Application Controller ---&amp;gt; Generator ---&amp;gt; Chart&lt;/code&gt;&lt;/p&gt;

&lt;h2 id="rendering"&gt;Rendering&lt;/h2&gt;

&lt;p&gt;I used Zurb's Pizza Amore pie library to generate the charts. While there are more sophisticated libraries out there such d3, I chose Pizza.js because it is lightweight and its simple charts are perfect for placeholder lorem ipsum.&lt;/p&gt;

&lt;p&gt;I knew I needed a headless browser to generate the charts. PhantomJS was the obvious choice since it has built-in svg support as well as the ability to take screenshots.&lt;/p&gt;

&lt;h2 id="caching"&gt;Caching&lt;/h2&gt;

&lt;p&gt;I first thought about setting up an E3 database to go with my Elastic Beanstalk instance. But why use a database when I could just place the images in the public folder? So that's what I did.&lt;/p&gt;

&lt;p&gt;Let's say I went to the url &lt;code&gt;localhost:3000/pie/300&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If this image has not been generated before, the url is converted to a path and passed into PhantomJS where it will be saved to the public folder. If the image already exists, the application controller calls the send_data method and sends the image located at the converted url path, in this case, &lt;code&gt;public/pie/300/300&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="the-source"&gt;The Source&lt;/h2&gt;

&lt;p&gt;I had a blast working on this project, and I do have plans to continue working on it. If you'd like to contribute, the project is open source on &lt;a href="https://github.com/NoahHines/Chartholdr"&gt;github&lt;/a&gt;.&lt;/p&gt;

</content>
  </entry>
  <entry>
    <title>Union Pacific Hackathon</title>
    <link rel="alternate" href="http://blog.url.com/2014/08/06/union-pacific-hackathon.html"/>
    <id>http://blog.url.com/2014/08/06/union-pacific-hackathon.html</id>
    <published>2014-08-06T00:00:00-04:00</published>
    <updated>2015-07-12T17:32:17-04:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;This past weekend, I had the privilege of competing in Union Pacific's first Intern Hackathon. The 24-hour event, filled with teamwork, caffeine, and unhealthy coding binges was, without a doubt, the highlight of my summer.&lt;/p&gt;

&lt;h3 id="hacking-to-safety"&gt;Hacking to Safety&lt;/h3&gt;
&lt;p&gt;After all nine teams set up their battlestations, the Hackathon problems were passed out. Our team chose "The Dangers of Highway-Rail Crossings". The problem listed statistics of the highway-rail crossing accidents that occur each year and greatly stressed the dangers these crossings present.
&lt;/p&gt;

&lt;p&gt;Let me quickly introduce the team.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cindy Chen - Electrical Engineer&lt;/li&gt;
  &lt;li&gt;Flavia Roma - Computer Science Engineer&lt;/li&gt;
  &lt;li&gt;Noah (me) - Computer Science Engineer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Covering hardware, Cindy had experience &lt;strong&gt;programming SDR&lt;/strong&gt; (Software Defined Radio) and was very interested in implementing signal processing into our solution.&lt;/p&gt;

&lt;p&gt;Covering software, Flavia had a lot of &lt;strong&gt;Java and scripting experience&lt;/strong&gt;, which we knew would help collect and organize any data we were given.&lt;/p&gt;

&lt;p&gt;Covering mobile development, I had &lt;strong&gt;iOS and Android experience&lt;/strong&gt;, which we knew would make our solution appealing for its ease of use and extendability.&lt;/p&gt;

&lt;h3 id="our-solution"&gt;Our Solution&lt;/h3&gt;
&lt;p&gt;We called the product &lt;strong&gt;Track Safety&lt;/strong&gt;: a three-part safety solution designed to decrease the number of highway-rail crossing accidents each year.&lt;/p&gt;

&lt;p&gt;First, an antenna is attached to the raspberry pi, which detects a train's EOT (End of Train signal) sent out every 60 seconds. This signal is used to send information between the end car and the locomotive at a set frequency. We simply listened for this frequency with a specific gain setting, waiting for the RSSI of the signal at that frequency to reach our set value.&lt;/p&gt;

&lt;p&gt;Second, a script is executed in response to receiving the EOT that sends an iBeacon advertisement to mobile devices.&lt;/p&gt;

&lt;p&gt;Third, nearby iPhones receive a push notification, warning them that a train will be crossing soon and that the area is now dangerous. If a user presses the notification to open the app, he/she will see the phone's current location and all the Union Pacific-owned highway-rail crossings in the state of Nebraska.&lt;/p&gt;

&lt;p&gt;Pretty straightforward, right? But given 24 hours and the goal of presenting a live demo, the project quickly became more and more stressful.&lt;/p&gt;

&lt;h4 id="software-defined-radio"&gt;Software Defined Radio&lt;/h4&gt;

&lt;p&gt;We used GNURadio to implement SDR. Thankfully, Cindy had experience programming custom blocks to interpret the radio signals. Our hope was to run both the SDR receiver and iBeacon BLE advertisements from the raspberry pi, but we were only able to achieve the latter. After reading a handful of tutorials, it seemed that the only way to install GNURadio on Raspibian was to download the source and compile the code with cmake. The source files take 24+ hours to compile, so we decided to run GNURadio from our linux laptop connected to the pi as a temporary solution. We hoped that stressing that this is a Proof of Concept and there is room for extendibility will let this laptop+pi solution stand strong.&lt;/p&gt;

&lt;h4 id="ble-advertisement"&gt;BLE Advertisement&lt;/h4&gt;

&lt;p&gt;We used a $10 Bluetooth 4.0 USB module powered by BlueZ to advertise iBeacon messages. There are some pretty straightforward tutorials online for getting the pi to send these advertisements. I wrote bash scripts to start and stop the advertisements so that the process would be as automated as possible. The hardest part of this process was testing that the pi was sending the advertisements. Thankfully, I found RadiusNetworks' Locate app, which allowed me to specify custom UUID, major, and minor values. For a free solution, RadiusNetworks' app is a godsend.&lt;/p&gt;

&lt;h4 id="ios-application"&gt;iOS Application&lt;/h4&gt;

&lt;p&gt;Union Pacific's IT dept. absolutely loves PhoneGap for its ease of use and simple cross-platform solution. We did not use PhoneGap, however, because our main goal was sending a push notification to the user's phone while the application is in the background. There are multiple PhoneGap plugins on GitHub that support iBeacon moitoring and ranging, but from what I can tell, there is not an easy method for implementing background iBeacon monitoring using PhoneGap.&lt;/p&gt;

&lt;p&gt;So insead, I used Xcode to program the native application. Starting with RadiusNetworks' background example, I built the app layer by layer.
+ Layer 1 - iBeacon Scanning
+ Layer 2 - Push Notification
+ Layer 3 - Google Map API&lt;/p&gt;

&lt;p&gt;pics&lt;/p&gt;

&lt;h3 id="tips-for-the-future"&gt;Tips for the Future&lt;/h3&gt;
&lt;p&gt;The main thing I learned from this event was: &lt;strong&gt;Your presentation will make or break you&lt;/strong&gt;. I saw great products flop and I saw not-so-great products look pretty awesome. The key is to tell a memorable story with your product. When you go on stage to present, it will be the very first time the judges see your project. By this time, you are so focused on your solution, that you can easily forget the big picture and may find yourself stressing low-level functions of your product that won't mean much to the judging panel. This doesn't mean keep the back-end a secret – but be sure to stress &lt;strong&gt;why the back-end is necessary to solve the problem&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This brings me to my second tip: &lt;strong&gt;Don't waste time on things the audience won't see&lt;/strong&gt;. I found myself wasting a lot of time optimising the push notification service on the iOS app. Those 2-3 hours I spent messing with that code added nothing to our final presentation because it was 100% back-end. Our product is a Proof of Concept – it doesn't matter if there are memory leaks!&lt;/p&gt;

&lt;h3 id="overview"&gt;Overview&lt;/h3&gt;
&lt;p&gt;By the end of the 24 hours, my major complaint was "Why do I have work tomorrow?" It seems really unfair that you lose your whole weekend to a programming event, but I quickly stopped complaining once my head hit the pillow. I highly recommend participating in a Hackathon. I think the best part of an event like this is realising that you were able to team up and create a functioning product in just one day.&lt;/p&gt;

</content>
  </entry>
</feed>
